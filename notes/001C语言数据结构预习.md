# 数据结构

* 集合，线性，树形，图形，
* 顺序存储：数据元素在存储器中连续存储；链式存储结构,每个数据元素里设置了一个指针用来指向另一个元素的存储地址,以此来表示数据元素之间的逻辑结构。
  
# 线性表

## 顺序表
### 定义
相同数据类型的。。。
## 基本操作
构造、插入、扩容、查找、删除、遍历

### 地址
设顺序表的第一个元素a0的存储地址为Loc(a0),每个元素占d个存储空间,则第i个元素的地址为
$\operatorname{Loc}\left(a_{i-1}\right)=\operatorname{Loc}\left(a_{0}\right)+(i-1) \times d$

### 静态分配动态分配

### 随机访问

通过下标在O(1)时间复杂度内找到指定元素

## 基本操作的实现

### 插入

#### 主要有两个部分：insert(loc,val);expand()

#### insert操作顺序：
1. 判断插入位置是否合法
2. 判断顺序表是否已满。
3. 将目标位置及之后的元素后移一位。
4. 将待插入的元素值插入到目标位置。
#### expand操作顺序：
1. 将原来的元素存储到临时存储空间。
2. 扩大原来的存储空间。
3. 将临时存储空间里的数据元素复制到新的存储空间里。
4. 释放临时的存储空间。

#### 结构体
    int size:最大容量
    int length:当前容器内元素数量
#### vector的模板，动态申请内存
```C
#include <stdio.h>
#include <stdlib.h>

typedef struct Vector {
    int size,length;
    int *data;
} Vector;

void init(Vector *vector, int size) {
    vector -> size = size;
    vector -> length = 0;
    vector -> data = (int *)malloc(sizeof(int) * size);
}

void clear(Vector *vector) {
    free(vector->data);
    free(vector);
}

int main() {
    Vector *a = (Vector *)malloc(sizeof(Vector));
    init(a, 100);
    clear(a);
    return 0;
}

```
#### insert部分
return ERROR，第一个是位置不合法，第二个可以改成后来的expand
```C
int insert(Vector *vector, int loc, int value) {
    if (loc < 0 || loc > vector->length) {
        return ERROR;
    }
    if (vector->length >= vector->size) {
        return ERROR;
        //expand(vector);
    }
    for (int i = vector->length; i > loc; --i) {
        vector->data[i] = vector->data[i - 1];
    }
    vector->data[loc] = value;
    vector->length++;
    return OK;
}
```
#### expand
```C
void expand(Vector *vector){
    int *old_data = vector->data;
    vector->size = vector->size*2;
    vector->data = (int *)malloc(sizeof(int)*vector->size);  
    for(int i=0;i<vector->length;i++){
        vector->data[i] = old_data[i];
    }
    free(old_data);
}
```

#### search(value)
查找值为value的元素，没有则返回-1
1. 从下标为0的元素开始依次枚举顺序表中的所有元素
2. 发现和目标值相等的元素则返回它的下标。
3. 枚举结束没有找到目标元素则返回-1
#### remove(index)
1. 判断传入的参数是否合法,即下标是否在顺序表的范围内
2. 将目标下标之后所有的元素前移一位。
3. 更新顺序表的长度。
#### print()
遍历，输出
```C
int search(Vector *vector, int value) {
    for (int i = 0; i < vector->length; ++i) {
        if (vector->data[i] == value) {
            return i;
        }
    }
    return -1;
}

int delete_node(Vector *vector, int index) {
    if (index < 0 || index >= vector->length) {
        return ERROR;
    }
    for (int i=index+1; i < vector->length; ++i) {
        vector->data[i-1] = vector->data[i];
    }
    vector->length--;
    return OK;
}
void print(Vector *vector) {
    for(int i=0;i<vector->length;++i){
        if(i>0){
            printf(" ");
        }
        printf("%d",vector->data[i]);
    }
    printf("\n");
}
```

## 链表
链表的构造、插入、遍历、删除、反转
### 基本操作
#### insert(node,index)
1. 找到链表中要插入的位置
2. 令待插入结点的next指针指向插入位置的当前结点
3. 令插入位置之前的当前结点的next指针指向待插入结点
#### output()
遍历

#### 链表的构造
```C
#include <stdio.h>
#include <stdlib.h>

typedef struct Node{
    int data;
    struct Node *next;
}Node, *LinkedList;

// insert
LinkedList insert(LinkedList head,Node* node,int index){
    if(head == NULL){
        if(index!=0){
            return head;
        }
        head = node;
        return head;
    }
    if(index==0){
        node->next = head;
        head = node;
        return head;
    }
    Node *current_node = head;
    int count = 0;
    while(current_node->next!=NULL && count<index-1){
        
        current_node = current_node->next;
        count++;
        
    }
    if(count == index-1){
    	node->next = current_node->next;
        current_node->next = node;
    }
    return head;
}

//output
void output(LinkedList head){
    if(head == NULL){
        return ;
    }
    Node *current_node = head;
    while(current_node!=NULL){
        printf("%d ",current_node->data);
        current_node = current_node->next;
    }
    printf("\n");
}

//clear
void clear(LinkedList head) {
    Node *current_node = head;
    while (current_node != NULL) {
        Node *delete_node = current_node;
        current_node = current_node->next;
        free(delete_node);
    }
}

int main() {
    LinkedList linkedlist = NULL;
    for(int i=1;i<=10;++i){
        Node *node = (Node *)malloc(sizeof(Node));
        node->data = i;
        node->next = NULL;
        linkedlist = insert(linkedlist,node,i-1);
    }
    output(linkedlist);
    clear(linkedlist);
    return 0;
}
```
#### delete_node(index)
1. 从表头遍历找到要删除的位置。
2. 令删除位置前一个结点的next指针指向待删除位置后一个结点。
3. 删除结点。


#### reverse
1. 定义一个用于遍历的指针,初始指向头结点后一个结点。
2. 让头结点的next指针置空
3. 从当前遍历指针所指的结点开始遍历链表,将遍历到的结点next指针指向头结点。遍历过程中借助另外一个指针保存下一个遍历到的结点
4. 重复步骤3直至表尾,此时新的链表就是原链表反转后的链表




