## 二叉查找树

1. 根节点为空则新元素直接作为根节点,否则传入的参数value与根节点进行比较。
2. value等于当前节点则直接返回,小于则跳转到步骤3,而如果value大于当前节点时,跳转到步骤4。
3. 判断当前节点是否存在左孩子,如果存在则让其左孩子继续调用插入方法,回到步骤2,如果不存在则将新元素插入到当前节点的左孩子位置上。
4. 判断当前节点是否存在右孩子,存在则让其右子树继续调用插入方法,回到步骤2,不存在则将新元素插入到当前节点的右孩子位置上。

### 二叉查找树的建立

二叉查找树在创建上它和二叉树几乎一样,只是二叉查找树多定义了一个`father`变量。

### 二叉查找树的元素删除
为了维护二叉查找树的特性,在其中删除元素时,要对以该元素为根节点的子树进行一定的调整。

在此之前,先来学习查找一个节点的**前驱和后继节点**的操作。节点的前驱指的是值比它小的节点中最大的一个节点,后继是指值比它大的节点中最小的一个。

查找节点**前驱**的算法流程如下:

1. 找到当前节点的左孩子,如果当前节点没有左孩子则不存在前驱,若存在,则找到其左孩子的右孩子。
2. 若当前节点有右孩子则继续找到其右孩子,重复步骤2,直至找到一个节点不存在右孩子时,那么它就是我们要查找的前驱。

删除一个节点时，要更新它的**孩子的父指针**，以及**父节点的的孩子指针**。

“只有一个孩子节点”
1. 如果当前节点仅存在左孩子,则更新左孩子的父节点为被删除节点的父节点。
2. 如果当前节点仅存在右孩子,则将其右孩子的父节点更新为被删除节点的父节点。
3. 更新被删除节点的父节点的孩子指针,使其原本指向被删除节点的指针指向被删除节点的孩子节点。
   
“有左右孩子的完整情况”

1. 找到被删除的节点。
2. 若它存在左孩子,则找到他的前驱,用前驱替換被删除节点的值,再调用删除节点的方法删除前驱。
3. 若被删除节点不存在左孩子,则找到它的后继,用后继替換被删除节点的值,再调用删除节点的方法删除后继。
4. 若被删除的节点不存在孩子节点,直接调用删除节点的的方法删除它

##  平衡二叉树

二叉树的问题

![0021](https://github.com/nilshao/notebook_kkb/raw/master/images/0021.png)

“balanced binary search tree”平衡二叉树，所有平衡二叉査找树基本由以下三个特征组成:
1. 自平衡条件
2. 旋转操作
3. 旋转的触发
   
平衡二叉查找树通过设置合理的自平衡条件,使得二叉查找树的查找、插入等操作的性能不至于退化到O(n),并且在进行二
又查找树的查找、插入等操作时进行判断,如果满足其中某个旋转的触发条件,则进行对应的旋转操作。

## 平衡二叉树————AVL树

### 自平衡条件

平衡因子：balance factor。每个结点的平衡因子是指它**左子树最大高度和右子树最大高度的差**。在AVL树中,平衡因子为-1、0、1的结点都被认为是平衡的,而平衡因子为一2、2等其他值的结点被认为是不平衡的,需要对这个结点所在子树进行调整。

### 单旋，多旋

* 单旋：在AVL树中,一共有两种单旋操作:**左旋和右旋**。AVL树通过一系列左旋和右旋操作,将不平衡的树**调整**为平衡二又查找树。

* 多旋：由两次单旋操作组合而成。左旋+右旋或右旋+左旋。

### 触发条件

插入、删除操作触发旋转：

在插入一个元素后不断回溯的过程中,如果因此导致结点不平衡,则根据不平衡情況(一定是一边子树比另一边子树的高度大**2**)进行对应的旋转:
1. 左子树比右子树的高度大2:
   * 如果新增元素插入到左儿子的左子树中,则进行右旋操作。(LL型调整
   * 如果新增元素插入到左儿子的右子树中,则进行左旋加右旋操作。(LR型调整)
2. 右子树比左子树的高度大2:
   * 如果新增元素插入到右儿子的右子树中,则进行左旋操作。(RR型调整) 
   * 如果新增元素插入到右儿子的左子树中,则进行右旋加左旋操作。(RL型调整)



## 平衡二叉树————SBtree树

size balanced tree

### 自平衡条件

![0022](https://github.com/nilshao/notebook_kkb/raw/master/images/0022.png)

### 旋转操作

基本的单次旋转同AVL

![0023](https://github.com/nilshao/notebook_kkb/raw/master/images/0023.png)

## 自平衡的二叉查找树————红黑树

红黑树也可以在O(logn)的时间复杂度内完成査找、插入和删除操作。红黑树相比于AVL,**牺牲了部分平衡性**以在插入、删除操作时**減少旋转操作**,整体性能优于AVL,也正因如此,C++STL中的**map就是用红黑树**实现的。

红黑树和其他平衡二叉查找树相比,增加了一个**颜色属性**,用来标识树上的结点是**红色还是黑色**;并且如果一个结点没有子结点,则该结点的子节点对应的指针为NIL,也就是说,红黑树的所有叶子都是NIL。基于此,我们给红黑树下一个定义一红黑树是满足如下条件的二叉查找树：

* 每个结点要么是红色,要么是黑色; 根结点是黑色;
* 叶结点(均为NIL)是黑色;
* 如果一个结点是红色,则它的两个子节点都是黑色的;
* **从根结点出发到所有叶结点的路径上,均包含相同数目的黑色结点**
  
### 插入
红黑树的插入操作和二叉查找树类似,在正常插入以后,要将插入的结点标为红色,并对树进行类似AVL和Sbtree的旋转调整,使得树满足红黑树的第四条规则,即每个红色结点的子节点都是黑色的。为什么要标记为红色呢?因为如果将结点标记为黑色,会使得第五条规则被破坏,很难通过旋转来调整,而通过旋转可以比较容昜地使得红色结点分隔开。

首先,给出三个定义
* 祖父结点:父结点的父结点
* 兄弟结点:当前结点为父结点的左孩子时,为父结点的右孩子; 当前结点为父结点的右孩子时,为父结点的左孩子 
* 叔父结点:父结点的兄弟结点

当插入之前的树为空时,新结点会位于树的根,根据第二条规则,将 新结点的颜色改为黑色就可以了。除此之外,当插入的新结点x的父 结点是红色时,需要从新结点出发向上进行调整,直到的父结点为 黑色,一共有三种情况

1. C的叔父结点是红色的
   此时的祖父结点一定是黑色的,因此将祖父结点的黑色改为红色,并将的父结点和叔父结点改为黑色。之后将的祖父结点作为x继续向上迭代。
2. x的叔父结点是黑色的,并且x是一个右孩子:
    对的祖父结点进行左旋(左旋操作和前面介绍的几种平衡二叉查找 树一致)后,及其父结点仍为红色,叔父结点仍为黑色,需要继续 对执行第三种调整。
3. x的叔父结点是黑色的,并且x是一个左孩子
    此时,将x的父结点改为黑色,祖父结点改为红色,并对x的祖父结点进行右旋。这时x的父结点为黑色,不需要再向上迭代调整

### 删除操作

和之前所学的二叉搜索树的删除操作类似,首先找到要删除的结点, 如果这个结点有两个子结点,那么可以把问题转化为删除只有一个子 结点的操作。为了统一,在接下来我们只分析删除只有一个孩子的结 点的情況(如果两个子结点都是NL1,那么将其中一个NIL当做子结 点就可以了

首先,我们先处理一些特殊情况。如果要删除的结点x为红色,那么这个结点的父结点和子结点都一定是黑色,因此,只需要把子结点直 接连向父结点就可以了,不会破坏红黑树的五条规则。而如果被删除 结点是黑色而其子结点是红色,也只需要把子结点替換上来,并将它的颜色改为黑色就可以了。

接下来所有情况的前提,都是待删除结点及其子结点都为黑色的情 况。首先将待删除结点的子节点替换到待删除结点上,标记为x,并 将x的兄弟结点标记为w。注意,此时x具有双重黑色,也就是 说,在计算路径上的黑色结点时,经过x要计两次数。所以在接下来 的例子里,不要为图片不符合红黑树定义而困惑,原因就在于“双重 黑色"的结点。

1. x的兄弟结点是红色的:
   
此时对x的父结点进行一次旋转,并改变x的父结点和兄弟结点的 颜色。这时,x的新兄弟结点是黑色的了,可以按照后面几种情况继 续处理。

2. x的兄弟结点是黑色的,并且w的两个子结点是黑色的
这时,去掉x的一重黑色,并将w改为红色,在x的父结点加上额 外的一重黑色(如果原来是红色,则改为黑色,否则改为双重黑 色)。接下来将x的父结点当做x,继续后续的调整操作。

3. x的兄弟结点w是黑色的,w的左孩子是红色的,w的右孩子是 黑色的
   
    此时,交換w和它的左孩子的颜色,然后对w进行右旋操作。现在 w的右孩子为红色,可以按照情况4进行处理。

4. x的兄弟结点w是黑色,且w的右孩子是红色的:
    此时,调整w及其父结点和右孩子的颜色,并对w的父结点进行一次左旋,可以使x去掉一重黑色。这时以根结点作为x,继续进行判断。


    ## 多路平衡查找树

    指树的结点有n个孩子








## 堆

堆可以看成是一棵完全二叉树,除最后一层以外,它的每一层都是填满的,最后一层从左到右依次填入。


### 插入堆

1. 把新元素保存在数组的最后。
2. 找到新插入元素的父节点位置
3. 将新元素与父节点比较大小。
4. 若新插入的元素与其父节点大小不符合堆序性则交換它和父节点的位置,并回到步骤2;若符合则插入操作完成。

### 删除元素

1. 将堆顶元素和最后一个元素交换
2. 删除堆的最后一个元素。
3. 自顶向下调整元素的位置,使之满足堆序性。

### 堆排序
1. 将变量i设为堆末下标
2. 交換堆顶和第i个元素
3. 自上到下调整堆顶到第i个元素之间的堆结构,使之保持堆序性
4. 将i前移一位,重复步骤2,直至i等于1。