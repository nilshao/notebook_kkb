# 数据结构

* 集合，线性，树形，图形，
* 顺序存储：数据元素在存储器中连续存储；链式存储结构,每个数据元素里设置了一个指针用来指向另一个元素的存储地址,以此来表示数据元素之间的逻辑结构。
  
# 线性表

## 顺序表
### 定义
相同数据类型的。。。
## 基本操作
构造、插入、扩容、查找、删除、遍历

### 地址
设顺序表的第一个元素a0的存储地址为Loc(a0),每个元素占d个存储空间,则第i个元素的地址为
$\operatorname{Loc}\left(a_{i-1}\right)=\operatorname{Loc}\left(a_{0}\right)+(i-1) \times d$

### 静态分配动态分配

### 随机访问

通过下标在O(1)时间复杂度内找到指定元素

## 基本操作的实现

### 插入

#### 主要有两个部分：insert(loc,val);expand()

#### insert操作顺序：
1. 判断插入位置是否合法
2. 判断顺序表是否已满。
3. 将目标位置及之后的元素后移一位。
4. 将待插入的元素值插入到目标位置。
#### expand操作顺序：
1. 将原来的元素存储到临时存储空间。
2. 扩大原来的存储空间。
3. 将临时存储空间里的数据元素复制到新的存储空间里。
4. 释放临时的存储空间。

#### 结构体
    int size:最大容量
    int length:当前容器内元素数量
#### vector的模板，动态申请内存
```C
#include <stdio.h>
#include <stdlib.h>

typedef struct Vector {
    int size,length;
    int *data;
} Vector;

void init(Vector *vector, int size) {
    vector -> size = size;
    vector -> length = 0;
    vector -> data = (int *)malloc(sizeof(int) * size);
}

void clear(Vector *vector) {
    free(vector->data);
    free(vector);
}

int main() {
    Vector *a = (Vector *)malloc(sizeof(Vector));
    init(a, 100);
    clear(a);
    return 0;
}

```
#### insert部分
return ERROR，第一个是位置不合法，第二个可以改成后来的expand
```C
int insert(Vector *vector, int loc, int value) {
    if (loc < 0 || loc > vector->length) {
        return ERROR;
    }
    if (vector->length >= vector->size) {
        return ERROR;
        //expand(vector);
    }
    for (int i = vector->length; i > loc; --i) {
        vector->data[i] = vector->data[i - 1];
    }
    vector->data[loc] = value;
    vector->length++;
    return OK;
}
```
#### expand
```C
void expand(Vector *vector){
    int *old_data = vector->data;
    vector->size = vector->size*2;
    vector->data = (int *)malloc(sizeof(int)*vector->size);  
    for(int i=0;i<vector->length;i++){
        vector->data[i] = old_data[i];
    }
    free(old_data);
}
```

#### search(value)
查找值为value的元素，没有则返回-1
1. 从下标为0的元素开始依次枚举顺序表中的所有元素
2. 发现和目标值相等的元素则返回它的下标。
3. 枚举结束没有找到目标元素则返回-1
#### remove(index)
1. 判断传入的参数是否合法,即下标是否在顺序表的范围内
2. 将目标下标之后所有的元素前移一位。
3. 更新顺序表的长度。
#### print()
遍历，输出
```C
int search(Vector *vector, int value) {
    for (int i = 0; i < vector->length; ++i) {
        if (vector->data[i] == value) {
            return i;
        }
    }
    return -1;
}

int delete_node(Vector *vector, int index) {
    if (index < 0 || index >= vector->length) {
        return ERROR;
    }
    for (int i=index+1; i < vector->length; ++i) {
        vector->data[i-1] = vector->data[i];
    }
    vector->length--;
    return OK;
}
void print(Vector *vector) {
    for(int i=0;i<vector->length;++i){
        if(i>0){
            printf(" ");
        }
        printf("%d",vector->data[i]);
    }
    printf("\n");
}
```

## 链表
链表的构造、插入、遍历、删除、反转
### 基本操作
#### insert(node,index)
1. 找到链表中要插入的位置
2. 令待插入结点的next指针指向插入位置的当前结点
3. 令插入位置之前的当前结点的next指针指向待插入结点
#### output()
遍历

#### 链表的构造
```C
#include <stdio.h>
#include <stdlib.h>

typedef struct Node{
    int data;
    struct Node *next;
}Node, *LinkedList;

// insert
LinkedList insert(LinkedList head,Node* node,int index){
    if(head == NULL){
        if(index!=0){
            return head;
        }
        head = node;
        return head;
    }
    if(index==0){
        node->next = head;
        head = node;
        return head;
    }
    Node *current_node = head;
    int count = 0;
    while(current_node->next!=NULL && count<index-1){
        
        current_node = current_node->next;
        count++;
        
    }
    if(count == index-1){
    	node->next = current_node->next;
        current_node->next = node;
    }
    return head;
}

//output
void output(LinkedList head){
    if(head == NULL){
        return ;
    }
    Node *current_node = head;
    while(current_node!=NULL){
        printf("%d ",current_node->data);
        current_node = current_node->next;
    }
    printf("\n");
}

//clear
void clear(LinkedList head) {
    Node *current_node = head;
    while (current_node != NULL) {
        Node *delete_node = current_node;
        current_node = current_node->next;
        free(delete_node);
    }
}

int main() {
    LinkedList linkedlist = NULL;
    for(int i=1;i<=10;++i){
        Node *node = (Node *)malloc(sizeof(Node));
        node->data = i;
        node->next = NULL;
        linkedlist = insert(linkedlist,node,i-1);
    }
    output(linkedlist);
    clear(linkedlist);
    return 0;
}
```
#### delete_node(index)
1. 从表头遍历找到要删除的位置。
2. 令删除位置前一个结点的next指针指向待删除位置后一个结点。
3. 删除结点。


#### reverse
1. 定义一个用于遍历的指针,初始指向头结点后一个结点。
2. 让头结点的next指针置空
3. 从当前遍历指针所指的结点开始遍历链表,将遍历到的结点next指针指向头结点。遍历过程中借助另外一个指针保存下一个遍历到的结点
4. 重复步骤3直至表尾,此时新的链表就是原链表反转后的链表

### 其他链表

双向链表，循环链表

#### 双向链表


#### 循环链表

**在循环链表里,头结点即是尾结点**

* 删除：析构函数中，把循环链表拆成单链表再删除
* 插入：当插入新结点时链表是空的,一般情况下,我们只需让新结点成为head,并让新的头结点指向它自己。我们在循环链表中是把head当做尾结点的,因此当**插入新结点的位置为0时,我们要更新head的指针。**
  
#### 循环链表实现约瑟夫环
1. 定义一个遍历指针,初始指向head,并让head指向空地址避免操作结束后变为野指针.
2. 找到遍历指针往后数的第n次所指向的结点
3. 输出该结点的数据,更新遍历指针,然后删除该结点。
4. 重复操作2直至只剩下最后一个结点
5. 输出最后一个结点并删除。


# 队列

FIFO先进先出

## 介绍
由于队列先进先出的特殊性质,我们在构造它时,需要用两个变量来代表队首和队尾的位置,设置这两个变量有利于我们去维 护队列的次序性。在**构造函数中,我们会将队首标记置为0,将队尾标记置为ー1**,并给队列分配内存空间。而在析构函数中,我们只要把分配给队列的数组空间释放。

接下来我们来学习队列的插入操作。我们在构造队列时,定义了一个队尾标记,在执行入队操作时,只需一直更新队尾标记就 能保持好队列元素间的先后关系。

## 基本操作

### 插入

1. 断队列是否已满。实际上是由于队尾标记不断增加,需要判断队尾标记是否大于数组长度。 
2. 更新队尾标记,将新插入元素存入队尾。

### 遍历

1. 输出队首标记所在的元素。
2. 队首标记后移一位。
3. 若队尾标记和队首标记相等,输出最后一个元素,否则返回步骤1。

### 出队

1. 比较队尾标记和队首标记的大小,当队首标记大于队尾标记则说明队列为空了,此时出队操作是非法的。
2. 令队首标记后移一位,队首标记后移即视作原队首出队了。

## queue的假上溢

之前的pop操作只是将head后移一位，如果一个队列在不断的执行插入、弹出、插入、弹出..那么可以想象,当执行到taiL达到队列上限之后,便不能再插入到队列中了,而此时队列其实是空的。

解决方式：**循环队列**

## 循环队列

循环队列以循环的方式来存储队列。当队尾标记taiL到达队列上限后,如果队列内的元素没有达到上限,就跳转到数组的开始位置,也就是0的位置,队首标记到达队列上限也采取同样的处理。通过这样的方法,我们就能够最大化利用内存空间,避免"假上溢”的情况出现。
### 插入
tail在增加1之后,需要对容量length取模,就能获得这次入队的元素要插入的位置了。

# 栈
LIFO
## 基本操作
用一个变量标记栈顶，初始化为-1
### insert

1. 判断栈是否已满,能否继续插入元素。
2. 栈顶标记后移一位。
3. 把新元素插入到当前栈顶标记的位置。

### pop
1. 判断栈是否为空,如果栈已经是空的,则返回 false。
2. 出栈操作只需要使栈顶标记減1就能实现栈顶元素的出栈了。


## 可以实现的功能

### 数列反转

1. 将一个数列的元素依次压入到栈中
2. 将栈顶元素出栈。
3. 判断栈是否为空,不为空则回到步骤2。

### 运算式计算

1. 使用两个栈分别存储数值和运算符
2. 读取表达式字符,数值存入数值栈,运算符和桟栊顶运算符比较优先级。
3. 通过运算符优先级不同选择将它压入栈或取出数值栈中两个元素进行计算,计算结果入栈。
4. 返回步骤2,直至表达式全部读完
5. 弹出一个运算符和两个数值进行运算,计算结果存储数值栈。
6. 当运算符栈不为空时,返回步骤5,否则数值栈中剩余的最后一个元素就是表达式求值结果

## 实现

max_size表示栈里最多可以有max_size个元素 top_ index表示**栈顶元素的位置**

## 单调栈

单调栈是栈内元素从栈顶到栈底单调递增或者单调递减的栈

单调栈的维护是O(n)时间复杂度

## 单调栈与木板接水





















# 图

## 基本概念

G=(V,E),V是点集，E是边集；有向边，无向边，有向图，无向图；稀疏图，稠密图

## 重点概念

* 度：依附于某个顶点的边的数量
* 出度：以顶点为弧尾的点的数目，入度：以顶点为弧头的弧的数目
* 邻接矩阵:n个顶点的n*n矩阵
![0015](https://github.com/nilshao/notebook_kkb/raw/master/images/0015.png)
    无向图的邻接矩阵是对称矩阵。出度：邻接矩阵中点对应行上所有值的和，入度：邻接矩阵中对应列上所有值的和。
* 邻接表
邻接表是图的一种顺序存储与链式存储相结合的存储方法。给图G中的每个顶点建立一个单链表,第个单链表中的结点表示依附于顶点的边(对于有向图是以v为起点的弧)。所有单链表的表头结点都存储在一个一维数组中,以便于顶点的访问。下图为图G1对应的邻接表。
![0016](https://github.com/nilshao/notebook_kkb/raw/master/images/0016.png)

邻接表可能对有向图求入度比较不友好。在无向图的邻接表中,顶点v的度为第i个单链表中的结点数;而在有向图中,第个单链表中的 结点数表示的是顶点v的出度,如果要求入度,则要遍历整个邻接表。另外,在邻接表中,我们很容易就能知道某一顶点和哪些顶点相连接

比较：稀疏图选邻接表，当稠密图需要考虑到附加链域，选稠密表

## 邻接矩阵的实现

n*n二维数组，且要初始化为全0；添加边的时候把对应位置设置为1。

## 邻接表的实现

## 图的遍历：生成树

## DFS

**思路：**

1. 访问当前顶点v,并将顶点标为已访问
2. 遍历与顶点v相邻的所有顶点c,然后对顶点v所有尚未被访问的相邻顶点c,递归地执行第1步操作。如果当前顶点已经没有未访问的相邻顶点了,则说明该分支搜索结束,沿通路回溯到顶点v
3. 此时如果还有相邻顶点没有被访问,则从该顶点继续开始深度优先搜索。直到所有顶点都被访问
   
**操作：**

1. 将要访问的第一个顶点v入栈,然后首先对其进行访问
2. 将顶点出栈,依次将与顶点v相邻且未被访问的顶点c压入栈中。
3. 重复第一步操作,直至栈为空，通常以递归的形式实现

## BFS

通常用于求起点到各个点的最短路径。

1. 选择图中任意一个顶点v作为起点进行访问,并将顶点标为已访问
2. 遍历并访问与顶点0相邻且未被访问的所有顶点c1,c2,…,Ck,接着遍历并访向与顶点c1,c2
,Ck相邻且未被访问的顶点,也就是依次访问所有相邻顶点的相邻顶点。以此类推,直到所
有顶点均被访问

通常使用队列实现

1. 任意选择一个顶点v作为起点,加入队列。
2. 访问队首元素v并标记,将其从队列中删除。
3. 遍历与顶点相邻且未被访问的所有顶点c1,c2,ck,...并依次加入到队列中。
4. 重复第二步和第三步操作,直到队列为空


# 哈希表

哈希表又叫散列表，哈希冲突

## 哈希函数的构造方法

* **直接寻址法**,即取关键字的值或者关键字的某个函数变换值,线性的 映射到存储地址上。如果关键字的数量和跨度不是很大,直接寻址法 是最简单最有效的构造方法了,并且还可以避免冲突。但是如果关键字的数量和跨度很大的话,这种方法就用不了了,例如有n个关键字,值最小的为0,最大的为10ˆ10,这种情况下就不能用直接寻址法因为没有足够的空间可用来存储。

* **除留余数法**,我们将关键字对整数p取的余数直接做为存储地址,整数p一般取**小于等于哈希表长度size的最大质数**,如果关键字不是整数,如是一个字符串,可以先将其做个转换,然后再对p取余,选择优秀的p可以减少冲突的发生。

总体要考虑：减少冲突，减少查询时间。













