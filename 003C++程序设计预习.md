
# 介绍

## CLI，

Command Line Interface，与GUI相对

#
## intro
* C++11
* 程序语言可以分为**机器语言,汇编语言和高级语言**三个层次一现阶段我们人类开发者**能够直接编写**的是**汇编语言**和**高级语言**,绝大多数情况下用到的还是高级语言。
* 高级语言的语句是由一些英语单词、数学公式等构成的，对于程序员来说,这些语句相对来说更浅显易懂,但是机器本身却只能识别0和1构成的二进制代码(也叫**机器码**)。那么,高级语言是怎么变成2进制代码的呢?这中间就要有一个过程需要一个“翻译器"来帮助我们完成这些事情。
* 具体地说,我们自己用高级语言写的程序,称为高级语言源程序,而将其转化成**二进制代码**之后的程序,称为**目标程序**一它已经是完全的二进制机器指令了,这个过程称为**编译**。那么,是不是有目标程序就能直接运行了呢?我们需要考虑到,如果个程序比较大的话,那么它可能要有多个模块来协作ー一就算是简单地向屏幕上输出一个" Aloha Oe",你也依然需要调用系统库里定义好的输出功能模块。
  
所以,我们需要把所有需要的**模块都合并**在一起,才能构成一个**可以执行**的程序一一这个就是程序的**链接**过程,链接完成之 后,オ会得到一个可以执行的程序。那么,你肯定要问:编译和链接过程该怎么进行呢?有一些专门的软件可以完成这个过程,这些软件被称为**编译器( Compiler)**和**链接器( Linker)**。

在编译和链接的过程中,都会对程序中的错误进行检查一一只有代码准确无误的程序才能编译成功。如果代码本身有错误的话 编译器就会报错,如下图所示。但是需要注意的是,**编译通过,并不代表程序本身是完全正确的**一一你仍然需要通过调试,确 认程序可以正确地运行,才能说你的程序是准确无误的。
* 除此之外,还有另一种与之类似的软件,称为解释器一一在介绍什么是“解释器"之前,我们首先要知道 **"编译型语言"**与 **“解释型 语言"**的差别。
所谓“编译型语言",指的是源程序的代码写好之后,编译器直接把高级语言的源代码编译成二进制的机器码,执行的时候直接运行机器码就行了ー一这门课程学习的C++语言,是一种典型的编译型语言;而"解释型语言"则与之不同,写好的代码不会马 上就被翻译成机器码,而是先保存成源程序的代码文件一等到运行的时候,这些语句オ会由解释器来一条一条地解释执行
一很多脚本语言,比如 Python,都属于解释型语言。

一般而言,**编译型语言拥有更高的运行效率,而解释型语言的可移植性更好**一一此外,还有一些介于两者之间的语言,比如 JAVA/C#,就是先编译成某种“中间代码"然后再交由不同平台的虚拟机解释执行的。



* 集成开发环境( Integrated Development Environment),简称IDE，就是把编辑器、解释器和其他的一系列工具整合在一起的产物
* 编译：
```C++
g++ Aloha0e.cpp -o Alpha0e
```
  其中,第一个参数代表要编译的文件,-0代表输出,最后一个参数代表你想要让编译器输出可执行文件的名字一一这里你可以 随意更改。如果你的程序没有错误的话,那么这条命令执行之后就不会返回任何提示一一反之则会报错并指出你的程序在哪里
出了偏差。编译完成之后就可以试着运行你的程序了一一在命令行中输入./ Aloha0e或者 Aloha0e就可以直接启动你已经编译
好的程序。

## 配置环境

## 第一个程序

从程序的结构中,我们就可以看出"连接"这个过程存在的意义:我们在主程序中调用了Iostream对应的库中定义好的cout对象,所以连接器在连接的时候,需要把我们写的代码跟相应的库连接起来,才能得到完整的可运行程序。

## 作用域

## 变量与数据类型

变量类型

unsigned,不需要留出一位来存储符号，直接存数字就行

## 换行

## 
注意不同：（且有分号）“流式”输入输出
```C++
using namespace std;
using std::cin;
```

## iomanip简单的io格式控制

```C++
#include <iomanip>
int a = 22;
std::cout << std::hex << a <<std::endl;
```

    输出16（hex是16进制）

## 地址

取地址符&，

```C++
    int a =0;
    int *p;
    p = &a;
```
辨析："变量"、“变量的值"、“变量的地址"、"特殊的用于存储地址的变量"

指针p也是变量

![0001](https://github.com/nilshao/notebook_kkb/raw/master/images/0001.png)


# 面向对象

## 面向对象程序设计的四个特点

抽象，继承，封装，朵态

## 抽象
```C++
class Clock{
public
    void setTime(int newH, int newM, int newS);
    void showtime();
private:
    int hour, minute, second;
}
```
一般来讲,对一个问题的抽象应该分为两个方面:**数据抽象**和**行为抽象**。前者描述某类对象的特性和状态,而后者则描述某类对象的功能或者行为特性。

public和 private的具体含义,后面的课程中我们会给出解释一这个定义的效果是:外界的程序不能直接访问三个成员变
量,只能通过两个函数来间接查看或者修改三个变量的值。这样做就可以实现对成员访问权限的合理控制,让不同类之间的相 互影响(耦合)减少到最低限度,进而增强数据的安全性,并简化程序编写工作。

举个简单的例子:还是对于 Clock类,如果不做封装的话外界的程序直接对三个变量进行访问假设有人故意要搞破坏,把表示时间的变量的值设置成一个根本不可能出现的值(比如设置成999小时999分钟),这就可能让程序出错。而进行封装之后,外界想要重新设置时间就必须通过settime()函数一一这样我们就可以在函数中增加检查输入合法性的代码,避免不合法数据的恶意输入。

## **继承**

## 实例化

当我们定义了ー个类之后,就可以定义这个类的变量,这个变量就是类的对象,或者叫做实例一一而这个定义的过程,则称为**实例化**。

## 类成员的初始值

函数的形参可以带有默认形参值，对于类的成员函数来说,这也是一样的调用规则与普通函数相同。
需要注意的是,**类成员函数的默认值一定要写在类的定义中**,**而不能写在类定义之外的函数实现里**。

## 构造函数

默认构造函数

复制构造函数：用一个已有的对象,来执行一个新的对象的构造。

复制构造函数具有一般构造函数的所有特性一一它的形参是本类的一个对象的**引用**, 为什么用引用来传参?初始化形参会造成很多额外的时间开销,浪费系统资源

![0002](https://github.com/nilshao/notebook_kkb/raw/master/images/0002.png)

![0003](https://github.com/nilshao/notebook_kkb/raw/master/images/0003.png)

构造函数可以做一些别的东西，比如一个Line类，初始化列表是两个Point类的object，然后构造函数体中计算len，作为Line类的另一个成员；

### 默认的复制构造函数

当类的数据成员有指针类型的时候，默认的复制构造函数只能实现**浅复制**，正确的复制是深复制。

### 初始化列表

```C++
Clock::Clock(int newS, int newM, int newH){
    second= newS;
    minute= newM;
    hour =newH;
}

```
使用初始化列表

```C++
Clock::Clock(int newS, int newM, int newH): second(newS),minute(newM), hour(newH){}
```

跟声明一个变変量类似,当我们声明一个对象的时候,发生的实际上也是"先初始化再执行具体操作”的过程一换句话说,用我 们之前的写法,就相当于是"先建立一个对象,初始化成员变量,然后再为成员变量一一赋值"。这个过程本身倒是没有什么错 误一一但很明显,大家不觉得它太麻烦了吗?我们不能一步到位,直接用要赋的值初始化成员变量吗?
答案当然是可以的一一事实上,这就是初始化列表存在的意义。在实际的程序执行中,一个类被实例化成一个对象,整个过程 实际上可以分为两个阶段:第一个阶段是对象的构造和成员变量的初始化初始化列表就是在此期间发挥作用的;而第二个 阶段,则是执行构造函数中的操作。

亳无疑问,在大多数情况下,使用初始化列表,或者是在构造函数中赋值,两种方法的效果是差不多的一一而初始化列表在效 率上相对于在构造函数中赋值,会存在一定的优势。如果函数的成员变量是基本数据类型的话,那么这优势不会十分明显 旦如果函数的成员变量是较为复杂的自定义数据类型(比如某个比较庞大的对象)的对象的话,那么初始化列表在调用开销的 节约方面,优势将会非常显著
此外,在某些情况下,比如需要初始化的数据成员是对象(继承时调用基类构造函数),需要初始化 const修饰的类成员,或者需
要初始化引用成员数据,都必须要使用初始化列表来进行初始化一相关的内容在后面的课程中,我们将向大家详细介绍。

## 访问类成员

![0004](https://github.com/nilshao/notebook_kkb/raw/master/images/0004.png)

## 类的组合

比如：
```C++
Point 类:int x,y,z;
Circle 类: Point center; int Radius;
```
构造函数的调用顺序：

1. 调用內嵌对象的构造函数,调用顺序按照內嵌对象在组合类中的定义中出现的顺序。需要注意的是,我们写在初始化列表 中的內嵌对象顺序,跟內嵌对象构造函数的调用顺序是没有关系的。
2. 执行本类构造函数的函数体。

析构函数和构造函数调用顺序相反

### sqrt函数
```C++
#include <cmath>
double len;
len = sqrt(x*x+y*y); 
```
### 类型强制转换
```C++
int a,b;
double x=static_cast<double>(a-b);

```

## 前向引用声明与结构体
例子：A，B类相互饮用
```C++
Class A{
public:
    void function (B b)
};
Class B{
public:
    void function (A a)
};

```
需要前向应用声明：
```C++
Class B;
Class A{
public:
    void function (B b)
};
Class B{
public:
    void function (A a)
};

```
需要注意的是,尽管使用了前向引用声明,但是在提供了一个完整的类定义之前,不能定义该类的对象,也不能在成员函数中使用该对象。也不能在类内的方法定义中直接调用定义不完善的类的方法

## struct结构体

默认public, class默认private。

### 为什么同时有struct 和class

