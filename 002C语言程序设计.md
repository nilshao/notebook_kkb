
## 占位符

![0005](https://github.com/nilshao/notebook_kkb/raw/master/images/0005.png)


## switch


```C++
switch(a){
    case 1:  [代码块1];break;
    case 2:  [代码块2];break;
    case 3:  [代码块3];break;
    default: [代码块default]  //如果123都不匹配
}
```

## a++,++a

对自增、自减运算符所在位置进行讨论了。
```C++
    printf("%d\n", a++);
    printf("%d\n", ++a);
```

假设现在a的取值为5,上面这两行代码中第一句会输出的值是5。

而同样在a取值为5的情况下使用第二句则会输出6。

这是因为表达式a++先被使用,之后再将a的值增加1,而++a则是先将a的值增加1然后才被使用。


## 递归

在一个函数的定义中调用自身的情况为**递归调用( ecursive call)**。在一般条件(如这里的n=1)满足时,返回一个确定的值,而在其他情况下,返回一个**包含本身函数**的递归调用的这种递归设计,被我们称为**头递归**(head recursion)。与头递归相对应,我们还有一个概念叫尾递归(taill recursion)。如果我们用尾递归实现求阶乘。

在**头递遡**归的实现中,我们在进行下一层的调用前, **没有进行计算**。在下一层返回后,我们才完成了这层的计算。

在**尾递归**的实现中,我们在进行下一层的调用前, 会**先进行计算**,而在最终一般条件满足时,会将算的结果逐层直接返回

## 函数地址作为函数参数

如果一个函数可以被传入另一个函数,当传入的函数不同时,同样的一个被传入函数就可能会产生不同的功能。

C语言中函数和变量类似,也是有自己的内存地址的。但是,函数不像变量一样可以进行**值传递**,我们在将其作为函数参数进行传递时,需要传递它的地址。
```C++
int g(float (*f)(int), int a) {
    return f(a)
} 
```

![0006](https://github.com/nilshao/notebook_kkb/raw/master/images/0006.png)


## 数组

### 声明和初始化

```C++
    int a[3];
    int b[2] = {2,3};
    int b[]={2,3};//如果初始化了也可以不用指定长度
```

## 字符串

scanf("%s",string); 而不是 scanf("%s", &string);

因为在C语言中，数组名可以直接当作数组所在内存地址

### 输出到字符串
标准输入输出库中的sprintf函数,它的功能是将格式化的数据**写入到一个字符串**。

我们已经定义了一个长度为100的名为information的字符串。现在将一些数据写入这个字符串中。

```C++
    char information[100];
    string name = "aaa";
    string gender = "bbb";
    sprintf(information,"%s is a %s", name, gender);
    printf("%s", information);
```

